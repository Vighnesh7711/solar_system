<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D Solar System</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body { margin: 0; overflow: hidden; }
        #infoPanel { 
            position: absolute; 
            top: 10px; 
            left: 10px; 
            background: rgba(0,0,0,0.8); 
            color: white; 
            padding: 15px; 
            border-radius: 8px;
            max-width: 300px;
            z-index: 100;
            display: none;
        }
        .planet-label {
            position: absolute;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 12px;
            pointer-events: none;
            text-shadow: 1px 1px 2px black;
        }
    </style>
</head>
<body class="bg-black">
    <div id="container" class="w-full h-screen"></div>
    
    <!-- Control Panel -->
    <div class="fixed top-4 right-4 bg-gray-900 bg-opacity-80 text-white p-4 rounded-lg space-y-3 text-xs">
        <div>
            <label class="block text-sm mb-1">Time Speed</label>
            <input type="range" id="timeSpeed" min="0" max="10" value="1" step="0.1" class="w-32">
            <span id="speedValue" class="text-xs ml-2">1x</span>
        </div>
        <div>
            <label class="block text-sm mb-1">Zoom</label>
            <input type="range" id="zoomControl" min="1" max="100" value="50" class="w-32">
        </div>
        <div class="flex items-center">
            <input type="checkbox" id="showOrbits" checked class="mr-2">
            <label class="text-sm mb-1">Show Orbits</label>
        </div>
        <div class="flex items-center">
            <input type="checkbox" id="showLabels" checked class="mr-2">
            <label class="text-sm mb-1">Show Labels</label>
        </div>
        <button id="resetCamera" class="mt-1 px-2 py-1 bg-blue-600 rounded text-xs hover:bg-blue-500">
            Reset View (R)
        </button>
        <div class="mt-2 border-t border-gray-700 pt-2">
            <p class="font-semibold mb-1">Keyboard Shortcuts</p>
            <p>L – Toggle Labels</p>
            <p>O – Toggle Orbits</p>
            <p>+ / - – Zoom</p>
            <p>R – Reset View</p>
        </div>
    </div>

    <!-- Planet Information Panel -->
    <div id="infoPanel">
        <h3 id="planetName" class="text-lg font-bold mb-2"></h3>
        <div id="planetInfo" class="text-sm"></div>
    </div>

    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000011);
        document.getElementById('container').appendChild(renderer.domElement);

        // Controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x333333);
        scene.add(ambientLight);
        
        const sunLight = new THREE.PointLight(0xffffff, 2, 300);
        scene.add(sunLight);

        // Texture loader
        const textureLoader = new THREE.TextureLoader();

        function loadTexture(path) {
            const texture = textureLoader.load(path);
            // For three.js r128, this improves color correctness on many displays
            if (texture.encoding !== undefined && THREE.sRGBEncoding !== undefined) {
                texture.encoding = THREE.sRGBEncoding;
            }
            return texture;
        }

        // Planet data
        const planets = [
            {
                name: "Mercury",
                radius: 0.4,
                distance: 10,
                speed: 4.1,
                color: 0x8C7853,
                rotationSpeed: 0.03,
                texture: "textures/mercury.png",
                info: "Closest planet to the Sun\nDiameter: 4,879 km\nOrbital Period: 88 days\nSurface Temp: -173°C to 427°C"
            },
            {
                name: "Venus",
                radius: 0.95,
                distance: 15,
                speed: 1.6,
                color: 0xE39E1C,
                rotationSpeed: 0.01,
                texture: "textures/venus.png",
                info: "Second planet from the Sun\nDiameter: 12,104 km\nOrbital Period: 225 days\nSurface Temp: 462°C"
            },
            {
                name: "Earth",
                radius: 1,
                distance: 20,
                speed: 1,
                color: 0x2233FF,
                rotationSpeed: 0.04,
                texture: "textures/earth.png",
                info: "Our home planet\nDiameter: 12,742 km\nOrbital Period: 365 days\nSurface Temp: -88°C to 58°C"
            },
            {
                name: "Mars",
                radius: 0.53,
                distance: 25,
                speed: 0.5,
                color: 0xFF3300,
                rotationSpeed: 0.03,
                texture: "textures/mars.png",
                info: "The Red Planet\nDiameter: 6,779 km\nOrbital Period: 687 days\nSurface Temp: -87°C to -5°C"
            },
            {
                name: "Jupiter",
                radius: 2.5,
                distance: 35,
                speed: 0.08,
                color: 0xC19A6B,
                rotationSpeed: 0.1,
                texture: "textures/jupiter.png",
                info: "Largest planet in our solar system\nDiameter: 139,820 km\nOrbital Period: 12 years\nGreat Red Spot storm"
            },
            {
                name: "Saturn",
                radius: 2.1,
                distance: 45,
                speed: 0.03,
                color: 0xFAD5A5,
                rotationSpeed: 0.08,
                texture: "textures/saturn.png",
                info: "Known for its rings\nDiameter: 116,460 km\nOrbital Period: 29 years\nHas 82 known moons"
            },
            {
                name: "Uranus",
                radius: 1.8,
                distance: 55,
                speed: 0.01,
                color: 0x4FD0E7,
                rotationSpeed: 0.05,
                texture: "textures/uranus.png",
                info: "Ice giant planet\nDiameter: 50,724 km\nOrbital Period: 84 years\nRotates on its side"
            },
            {
                name: "Neptune",
                radius: 1.7,
                distance: 65,
                speed: 0.006,
                color: 0x4B70DD,
                rotationSpeed: 0.05,
                texture: "textures/neptune.png",
                info: "Windiest planet\nDiameter: 49,244 km\nOrbital Period: 165 years\nStrongest winds in solar system"
            }
        ];

        // Create Sun with texture
        const sunGeometry = new THREE.SphereGeometry(3, 64, 64);
        const sunMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xFFFF00,
            map: loadTexture("textures/sun.png"),
            emissive: 0xFFFF00,
            emissiveIntensity: 0.8
        });
        const sun = new THREE.Mesh(sunGeometry, sunMaterial);
        scene.add(sun);

        // Create planets, orbits, labels
        const planetObjects = [];
        const orbitObjects = [];
        const labelObjects = [];
        const planetDataMap = new Map(); // Map planet name to mesh

        let saturnMesh = null; // to attach rings

        planets.forEach((planet) => {
            // Create planet
            const geometry = new THREE.SphereGeometry(planet.radius, 48, 48);
            const materialOptions = {
                color: planet.color
            };
            if (planet.texture) {
                materialOptions.map = loadTexture(planet.texture);
            }
            const material = new THREE.MeshLambertMaterial(materialOptions);
            const planetMesh = new THREE.Mesh(geometry, material);
            
            // Position planet
            const angle = Math.random() * Math.PI * 2;
            planetMesh.position.x = planet.distance * Math.cos(angle);
            planetMesh.position.z = planet.distance * Math.sin(angle);
            
            planetMesh.userData = {
                name: planet.name,
                info: planet.info,
                distance: planet.distance,
                speed: planet.speed,
                angle: angle,
                rotationSpeed: planet.rotationSpeed,
                radius: planet.radius
            };
            
            scene.add(planetMesh);
            planetObjects.push(planetMesh);
            planetDataMap.set(planet.name, planetMesh);

            if (planet.name === "Saturn") {
                saturnMesh = planetMesh;
            }

            // Create orbit path
            const orbitGeometry = new THREE.RingGeometry(planet.distance - 0.1, planet.distance + 0.1, 64);
            const orbitMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x444444, 
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.3
            });
            const orbit = new THREE.Mesh(orbitGeometry, orbitMaterial);
            orbit.rotation.x = Math.PI / 2;
            scene.add(orbit);
            orbitObjects.push(orbit);

            // Create label
            const label = document.createElement('div');
            label.className = 'planet-label';
            label.textContent = planet.name;
            document.body.appendChild(label);
            labelObjects.push(label);
        });

        // --- Saturn Rings (textured & tilted) ---
        if (saturnMesh) {
            const innerRingRadius = saturnMesh.userData.radius * 2.2;
            const outerRingRadius = saturnMesh.userData.radius * 3.6;


            const ringGeometry = new THREE.RingGeometry(innerRingRadius, outerRingRadius, 128);
            const ringTexture = loadTexture("textures/saturn_ring.png");
            ringTexture.wrapS = THREE.ClampToEdgeWrapping;
            ringTexture.wrapT = THREE.ClampToEdgeWrapping;
            const ringMaterial = new THREE.MeshBasicMaterial({
                map: ringTexture,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.9
            });

            const saturnRings = new THREE.Mesh(ringGeometry, ringMaterial);
            saturnRings.rotation.x = Math.PI / 2;
            saturnRings.rotation.z = 0.4; // tilt the rings
            saturnMesh.add(saturnRings);
        }

        // Stars background
        const starGeometry = new THREE.BufferGeometry();
        const starCount = 5000;
        const positions = new Float32Array(starCount * 3);
        
        for (let i = 0; i < starCount * 3; i += 3) {
            positions[i] = (Math.random() - 0.5) * 2000;
            positions[i + 1] = (Math.random() - 0.5) * 2000;
            positions[i + 2] = (Math.random() - 0.5) * 2000;
        }
        
        starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const starMaterial = new THREE.PointsMaterial({ color: 0xFFFFFF, size: 1 });
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);

        // --- Moons (Earth + Jupiter) ---
        const moons = [];

        function createMoon(parentName, options) {
            const parent = planetDataMap.get(parentName);
            if (!parent) return;

            const geom = new THREE.SphereGeometry(options.radius, 16, 16);
            const matOptions = { color: options.color };
            if (options.texture) {
                matOptions.map = loadTexture(options.texture);
            }
            const mat = new THREE.MeshLambertMaterial(matOptions);
            const moon = new THREE.Mesh(geom, mat);
            scene.add(moon);

            moons.push({
                mesh: moon,
                parent: parent,
                distance: options.distance,
                speed: options.speed,
                angle: Math.random() * Math.PI * 2
            });
        }

        // Earth: 1 Moon
        createMoon("Earth", {
            radius: 0.27,
            distance: 2,
            speed: 1.5,
            color: 0xCCCCCC,
            texture: null // you can set "textures/moon.jpg"
        });

        // Jupiter: 4 large moons (simplified)
        for (let i = 0; i < 4; i++) {
            createMoon("Jupiter", {
                radius: 0.3,
                distance: 3 + i * 0.8,
                speed: 0.5 + i * 0.2,
                color: 0xAAAAAA,
                texture: null
            });
        }

        // --- Asteroid Belt (moved so it doesn't touch Jupiter) ---
        const asteroidCount = 1500;
        const asteroidPositions = new Float32Array(asteroidCount * 3);

        // Mars distance = 25, Jupiter = 35 => place belt ~27–31
        const innerRadius = 27;
        const outerRadius = 31;

        for (let i = 0; i < asteroidCount; i++) {
            const t = Math.random() * Math.PI * 2;
            const r = innerRadius + Math.random() * (outerRadius - innerRadius);
            const y = (Math.random() - 0.5) * 1.5; // small vertical spread

            const idx = i * 3;
            asteroidPositions[idx] = r * Math.cos(t);
            asteroidPositions[idx + 1] = y;
            asteroidPositions[idx + 2] = r * Math.sin(t);
        }

        const asteroidGeometry = new THREE.BufferGeometry();
        asteroidGeometry.setAttribute('position', new THREE.BufferAttribute(asteroidPositions, 3));
        const asteroidMaterial = new THREE.PointsMaterial({ size: 0.25, color: 0x888888 });
        const asteroidBelt = new THREE.Points(asteroidGeometry, asteroidMaterial);
        scene.add(asteroidBelt);

        // Camera position
        function resetCamera() {
            camera.position.set(0, 30, 50);
            controls.target.set(0, 0, 0);
            controls.update();
        }
        resetCamera();

        // Animation variables
        let timeSpeed = 1;

        // Camera focus animation state
        let cameraAnim = {
            active: false,
            startTime: 0,
            duration: 1200,
            fromPos: new THREE.Vector3(),
            toPos: new THREE.Vector3(),
            fromTarget: new THREE.Vector3(),
            toTarget: new THREE.Vector3()
        };

        function focusOnPlanet(planetMesh) {
            cameraAnim.active = true;
            cameraAnim.startTime = performance.now();
            cameraAnim.fromPos.copy(camera.position);
            cameraAnim.fromTarget.copy(controls.target);

            const target = planetMesh.position.clone();
            cameraAnim.toTarget.copy(target);

            // Offset camera relative to planet
            const offset = new THREE.Vector3(0, planetMesh.userData.radius * 6, planetMesh.userData.radius * 10);
            cameraAnim.toPos.copy(target).add(offset);
        }

        function smoothstep(t) {
            return t * t * (3 - 2 * t);
        }

        // Event listeners for controls
        document.getElementById('timeSpeed').addEventListener('input', (e) => {
            timeSpeed = parseFloat(e.target.value);
            document.getElementById('speedValue').textContent = timeSpeed.toFixed(1) + 'x';
        });

        document.getElementById('zoomControl').addEventListener('input', (e) => {
            const zoomValue = parseFloat(e.target.value);
            camera.position.z = 20 + (zoomValue * 0.8);
        });

        document.getElementById('showOrbits').addEventListener('change', (e) => {
            orbitObjects.forEach(orbit => {
                orbit.visible = e.target.checked;
            });
        });

        document.getElementById('showLabels').addEventListener('change', (e) => {
            labelObjects.forEach(label => {
                label.style.display = e.target.checked ? 'block' : 'none';
            });
        });

        document.getElementById('resetCamera').addEventListener('click', () => {
            resetCamera();
        });

        // Planet click handler
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        function onMouseClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(planetObjects);
            
            const infoPanel = document.getElementById('infoPanel');

            if (intersects.length > 0) {
                const planet = intersects[0].object;
                document.getElementById('planetName').textContent = planet.userData.name;
                document.getElementById('planetInfo').innerHTML = planet.userData.info.replace(/\n/g, '<br>');
                infoPanel.style.display = 'block';

                // Smooth camera focus on clicked planet
                focusOnPlanet(planet);
            } else {
                infoPanel.style.display = 'none';
            }
        }

        window.addEventListener('click', onMouseClick);

        // Keyboard controls
        window.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            if (key === 'r') {
                resetCamera();
            } else if (key === 'l') {
                const checkbox = document.getElementById('showLabels');
                checkbox.checked = !checkbox.checked;
                checkbox.dispatchEvent(new Event('change'));
            } else if (key === 'o') {
                const checkbox = document.getElementById('showOrbits');
                checkbox.checked = !checkbox.checked;
                checkbox.dispatchEvent(new Event('change'));
            } else if (key === '+') {
                const zoomControl = document.getElementById('zoomControl');
                zoomControl.value = Math.max(1, zoomControl.value - 5);
                zoomControl.dispatchEvent(new Event('input'));
            } else if (key === '-') {
                const zoomControl = document.getElementById('zoomControl');
                zoomControl.value = Math.min(100, parseInt(zoomControl.value) + 5);
                zoomControl.dispatchEvent(new Event('input'));
            }
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Update planet positions (orbit) & rotations (spin)
            planetObjects.forEach((planet, index) => {
                const data = planet.userData;
                // Orbit
                data.angle += (data.speed * timeSpeed) * 0.01;
                planet.position.x = data.distance * Math.cos(data.angle);
                planet.position.z = data.distance * Math.sin(data.angle);
                // Spin
                planet.rotation.y += (data.rotationSpeed || 0.02) * timeSpeed;

                // Update labels
                if (document.getElementById('showLabels').checked) {
                    const vector = planet.position.clone();
                    vector.project(camera);
                    const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                    const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
                    labelObjects[index].style.left = x + 'px';
                    labelObjects[index].style.top = y + 'px';
                    labelObjects[index].style.display = 'block';
                } else {
                    labelObjects[index].style.display = 'none';
                }
            });

            // Update moons
            moons.forEach(moon => {
                moon.angle += moon.speed * timeSpeed * 0.02;
                const parentPos = moon.parent.position;
                moon.mesh.position.set(
                    parentPos.x + moon.distance * Math.cos(moon.angle),
                    parentPos.y,
                    parentPos.z + moon.distance * Math.sin(moon.angle)
                );
            });

            // Rotate asteroid belt slowly
            asteroidBelt.rotation.y += 0.0005 * timeSpeed;

            // Rotate Sun
            sun.rotation.y += 0.002 * timeSpeed;

            // Camera focus animation
            if (cameraAnim.active) {
                const now = performance.now();
                let t = (now - cameraAnim.startTime) / cameraAnim.duration;
                if (t >= 1) {
                    t = 1;
                    cameraAnim.active = false;
                }
                const s = smoothstep(t);
                camera.position.lerpVectors(cameraAnim.fromPos, cameraAnim.toPos, s);
                controls.target.lerpVectors(cameraAnim.fromTarget, cameraAnim.toTarget, s);
            }

            controls.update();
            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start animation
        animate();
    </script>
</body>
</html>
